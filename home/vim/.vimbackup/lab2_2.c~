/**
 * James choi
 * Lab #2 - Procedure Part 1.c
 * If user presses G, turn green LED on, if user press Y, turn Yellow LED on.  Toggle for both */
#include "msp430fg4618.h"
#include "stdio.h"
#include "string.h"

/* Initializes various register values for desired UART settings
 * Sets P2.4 to tx and P2.5 to rx
 * Until all settings are set, the UART is held in reset mode.
 * then then all settings are set, it is taken out of reset mode.  */
void Init_UART(void);

/* Polls UCA0TXIFG until a 1 is found, when UCA0TXBUF is empty, and then
 * transmits an ASCII character passed to it as an unsigned char with values
 * in between 0 and 255 by writing it to UCA0TXBUF */
void OUTA_UART(unsigned char A);

/* Continuously reads UCA0RXIFG flag until 1. Then when 1 is encountered,
 * it reads UCA0RXBUF to obtain the received data (An AsCII character) */
unsigned char INCHAR_UART(void);

/* Turns on corresponding LED based on G or Y pressed */
int readColor();


int main(void) {
    /* Declare / Initialize */
    volatile unsigned char a;
    volatile unsigned int i;         // volatile to prevent optimization
    Init_UART();                                 // Initialize UART
    WDTCTL = WDTPW + WDTHOLD;         // Stop watchdog timer

    int wrd;

    P2DIR |= 0x06 ; // SeT P2.1 && P2.2 as output using Direction Control for output ( 0x06 == 110 )

    // Keep reading an input turn on corresponding LED
    for (;;) {
        // get a char input
        P2OUT ^= readColor();
    }
}

int readColor(){
    // Get a char
    char a = INCHAR_UART();;

    // Pressed G
    if ( a == 0x47 ){
        // Return Green
        return 0x04 ;
    }
    // Pressed Y
    else if ( a == 0x59 ){
        // Return Yellow
        return 0x02 ;
    }
    // Pressed some other key
    else{
        return 0x00 ;
    }
}



void OUTA_UART(unsigned char A) {
	do {}
	while ((IFG2 & 0x02) == 0);
	UCA0TXBUF = A;
}

unsigned char INCHAR_UART(void) {
	do {}
	while ((IFG2 & 0x01) == 0);
	return (UCA0RXBUF);
}

void Init_UART(void) {
	P2SEL = 0x30;       // transmit and receive to port 2 bits 4 and 5
	UCA0CTL0 = 0;       // 8 data, no parity 1 stop, uart, async
	UCA0CTL1 = 0x41;
	UCA0BR1 = 0;        // upper byte of divider clock word
	UCA0BR0 = 3;        // clock divide from a clock to bit clock 32768/9600
	UCA0MCTL = 0x06;
	UCA0STAT = 0;       // do not loop the transmitter back to the
	UCA0CTL1 = 0x40;
	IE2 = 0;            // turn transmit interrupts off
}

