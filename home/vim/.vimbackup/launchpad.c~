#include "launchpad.h"
#include <stdint.h>

/* LaunchPad I/O port assignments */
#define LED_RED     BIT0        // P1.0: Red LED
#define LED_GREEN   BIT6        // P1.6: Green LED
#define UART_TXD    BIT1        // P1.1 (Timer_A.OUT0): UART TxD
#define UART_RXD    BIT2        // P1.2 (Timer_A.CCI1A): UART RxD
#define BUTTON      BIT3        // P1.3: Push Button

/* UART timing constant: bit_time = timerA_clock / baid_rate */
#define UART_BITTIME    (TIMERA_CLOCK / UART_BAUD)

/* Number of system clock ticks per second */
#define SYS_SECOND      ((TIMERA_CLOCK + 32768UL) / 65536UL)

/* Sleep timer */
static uint16_t sleep_timer;

void sys_init(void){

    /* stop WDT */
    WDTCTL = WDTPW + WDTHOLD;

    /* initialize system clock: DCO=1MHz MCLK=/1, SMCLK=/1*/
    BCSCTL1 = CALBC1_1MHZ;
    DCOCTL = CALDCO_1MHZ;
    BCSCTL2 = 0;

    /* initialize IO pins */
    BIT_SET(P1DIR, LED_RED | LED_GREEN | UART_TXD); // outputs
    BIT_CLR(P1OUT, LED_GREEN | LED_RED);            // LEDs Off
    BIT_SET(P1SEL, UART_TXD);                       // assigned to Timer_A

    /* configure Timer_A in continuous mode using SMCLK as a source */
    TACTL = TASSEL_2 + MC_2 + ID_2 + TAIE;

    /* initialize "UART" */
    TACCTL0 = OUT;

    /* enable interrupts */
    __enable_interrupt();
}

/**
  brief  Transmits a single character using Timer_A.
  This is a blocking function. It will not return untill the character has
  been transmitted. For example, it takes 1.04 ms to transmit a character at
  9600 bps Baud rate.
 **/
void sys_putch(char c){
    uint16_t txd = c | 0x300;       // transmitter "shift register"

    /* Start transmitter. This has to be done with interrupts disabled */
    __disable_interrupt();
    TACCTL0 = 0;                    // transmit start bit
    TACCR0 = TAR + UART_BITTIME;    // set time till the first data bit
    __enable_interrupt();

    while (txd) {
        if (txd & 1) {
            /* transmit "Mark" (1) using OUTMOD=1 (Set) */
            TACCTL0 = OUTMOD_1;
        } else {
            /* transmit "Space" (0) using OUTMOD=5 (Reset) */
            TACCTL0 = OUTMOD_5;
        }

        /* wait for TA compare event */
        while (0 == BIT_TEST(TACCTL0, CCIFG));

        /* set next bit time */
        TACCR0 += UART_BITTIME;

        txd >>= 1;
    }

    /* all bits sent out; set TxD idle to "Mark" */
    TACCTL0 = OUT;
}

/**
brief  Suspend execution for a specified number of seconds.
**/
void sys_sleep(unsigned s){
    /* dont't enter sleep mode if s == 0! */
    if (s) {
        __disable_interrupt();

        sleep_timer = s * SYS_SECOND;

        /* enter LPM0 with interrupts enabled */
        __bis_SR_register(LPM0_bits + GIE);
    }
}

/**
  brief  Timer_A1 interrupt handler: System heartbeat
**/
#pragma vector = TIMERA1_VECTOR
__interrupt void timerA1_isr(void){
    /* use calculated branching */
    switch (__even_in_range(TAIV, TAIV_TAIFG)) {
    case TAIV_TAIFG:                    // timer overflow
        BIT_TOGGLE(P1OUT, LED_GREEN);   // toggle green LED

        /* if the sleep timer has expired then wake up CPU */
        if (sleep_timer > 0 && --sleep_timer == 0) {
            __bic_SR_register_on_exit(LPM0_bits);
        }
        break;
    }
}
