/**
 * James choi
 * Lab #3 - Procedure Part 3
 * Asks for a user input. If user input is captital, it will lowercase.
 * If lowercase it will captitalize it
 */

#include "msp430fg4618.h"
#include "stdio.h"
#include "string.h"
#include "math.h"
#include "stdlib.h"
#define SPACE 0x20
#define LF 0x0A
#define CR 0x0D

/* Initializes various register values for desired UART settings
 * Sets P2.4 to tx and P2.5 to rx
 * Until all settings are set, the UART is held in reset mode.
 * then then all settings are set, it is taken out of reset mode.  */
void Init_UART(void);

/* Polls UCA0TXIFG until a 1 is found, when UCA0TXBUF is empty, and then
 * transmits an ASCII character passed to it as an unsigned char with values
 * in between 0 and 255 by writing it to UCA0TXBUF */
void OUTA_UART(unsigned char A);

/* Continuously reads UCA0RXIFG flag until 1. Then when 1 is encountered,
 * it reads UCA0RXBUF to obtain the received data (An AsCII character) */
unsigned char INCHAR_UART(void);

//---------------------------------------------------------------
// Console I/O through the on board UART for MSP 430X4XXX
//---------------------------------------------------------------
unsigned int readBinary();
unsigned char getValidInput(void);
unsigned char getAZ(void);
void toBinary(int n);
int toValue(unsigned char c);
void toBinaryW(int n);
int asciiToValue(int n);
void valueToAscii(int n);
void printArray(int * array);
void read();
int main(void) {

    volatile unsigned char a;
    volatile unsigned char b; 	// volatile to prevent optimization
    WDTCTL = WDTPW + WDTHOLD;   // Stop watchdog timer
    Init_UART();				// Intialize UART for hyperterminal

    for (;;) {
        read();
        OUTA_UART(CR);
        OUTA_UART(LF);
    }
}

void read(){
    int in = 0 ;
    int k = 0 ;
    int array[32] ;
    while (in != 0x0D && k < 32){
        in = INCHAR_UART();
        if ( in != 0x0D ){
            array[k] = in  ;
            OUTA_UART((char)array[k]);
            k++ ;
        }
        else{
            array[k] = 0x00 ;
            k++ ;
        }
    }

    int i = 0 ;
    int j = 0 ;
    for (i = 0; i < k-1; i++ ) {
        for (j = 0; j < k-1; j++) {
            if (array[j] > array[j+1]) {
                int temp = array[j];
                array[j] = array[j + 1];
                array[j+1] = temp;
            }
        }
    }
    OUTA_UART(CR);
    OUTA_UART(LF);
    for ( i = 0 ; i < k ; i++ ){
        OUTA_UART(array[i]);
    }
}
unsigned int readBinary(){
    int k = 7 ;
    int sum = 0;
    unsigned char in ;
    while ( k > -1 ){
        in = INCHAR_UART();
        if ( in == 0x30 ){
            OUTA_UART(in);
            k-- ;
        }
        else if ( in == 0x31 ){
            OUTA_UART(in);
            sum+=pow(2,k);
            k-- ;
        }
        else continue ;
    }
    return sum ;
}
unsigned char getAZ(void) {
    unsigned char a = 0x00;
    // while a isn't a valid input( character A-F or a-f )
    while (1) {
        // get a char
        a = INCHAR_UART();
        /* Check if the chracter in a, is 0-9 or A-F or a-f */
        // If 0-9

        // elif A-F
        if (a > 0x40 && a < 0x5B ) {
            OUTA_UART(a+0x20);
            return a;
        }
        // elif a-f
        else if (a > 0x60 && a < 0x7B) {
            OUTA_UART(a - 0x20);
            return a - 0x20;
        }
        // Reset a and reiterate
        else {
            a = 0x00;
        }
    }
}
void valueToAscii(int n) {
    if (n > 9) {
        OUTA_UART(n + 0x37);
    } else {
        OUTA_UART(n + 0x30);
    }
}
void toBinary(int n) {
    if (n <= 0) {
        return;
    } else {
        toBinary(n / 2);
        OUTA_UART(n % 2 + 0x30);
    }
}

void toBinaryW(int n) {
    int k = 0;
    if (n == 0) {
        k = 4;
    } else if (n == 1) {
        k = 3;
    } else if (n == 2 || n == 3) {
        k = 2;
    } else if (n > 3 && n < 8) {
        k = 1;
    } else {
        k = 0;
    }
    int i = 0;
    for (i = 0; i < k; i++) {
        OUTA_UART(0x30);
    }
    toBinary(n);
}

int asciiToValue(int n) {
    if (n > 0x2F && n < 0x3A) {
        return n - 0x30;
    } else {
        return n - 0x37;
    }
}

unsigned char getValidInput(void) {
    unsigned char a = 0x00;
    // while a isn't a valid hex digit ( character 0-9 or character A-F or a-f )
    while (1) {
        // get a char
        a = INCHAR_UART();
        /* Check if the chracter in a, is 0-9 or A-F or a-f */
        // If 0-9
        if (a > 0x2F && a < 0x40) {
            OUTA_UART(a);
            return a;
        }
        // elif A-F
        else if (a > 0x40 && a < 0x47) {
            OUTA_UART(a);
            return a;
        }
        // elif a-f
        else if (a > 0x60 && a < 0x67) {
            OUTA_UART(a - 0x20);
            return a - 0x20;
        }
        // Reset a and reiterate
        else {
            a = 0x00;
        }
    }

}

void OUTA_UART(unsigned char A) {
    do {
    } while ((IFG2 & 0x02) == 0);
    UCA0TXBUF = A;
}

unsigned char INCHAR_UART(void) {
    do {
    } while ((IFG2 & 0x01) == 0);
    return (UCA0RXBUF);
}

void Init_UART(void) {
    P2SEL = 0x30;       // transmit and receive to port 2 bits 4 and 5
    UCA0CTL0 = 0;       // 8 data, no parity 1 stop, uart, async
    UCA0CTL1 = 0x41;
    UCA0BR1 = 0;        // upper byte of divider clock word
    UCA0BR0 = 3;        // clock divide from a clock to bit clock 32768/9600
    UCA0MCTL = 0x06;
    UCA0STAT = 0;       // do not loop the transmitter back to the
    UCA0CTL1 = 0x40;
    IE2 = 0;            // turn transmit interrupts off
}
