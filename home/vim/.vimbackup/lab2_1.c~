/**
 * James choi
 * Lab #2 - Procedure Part 1   */

#include "msp430fg4618.h"
#include "stdio.h"
#include "string.h"

/* Initializes various register values for desired UART settings
 * Sets P2.4 to tx and P2.5 to rx
 * Until all settings are set, the UART is held in reset mode.
 * then then all settings are set, it is taken out of reset mode.  */
void Init_UART(void);

/* Polls UCA0TXIFG until a 1 is found, when UCA0TXBUF is empty, and then
 * transmits an ASCII character passed to it as an unsigned char with values
 * in between 0 and 255 by writing it to UCA0TXBUF */
void OUTA_UART(unsigned char A);

/* Continuously reads UCA0RXIFG flag until 1. Then when 1 is encountered,
 * it reads UCA0RXBUF to obtain the received data (An AsCII character) */
unsigned char INCHAR_UART(void);

/* Prints to hyperterminal via serial output the given arg*/
void stringout(char Str2[]) ;


int main(void) {
  /* Declare / Initialize */
  volatile unsigned char a;
  volatile unsigned int i; 	// volatile to prevent optimization
  Init_UART(); 				// Initialize UART
  WDTCTL = WDTPW + WDTHOLD; 	// Stop watchdog timer

  char word[] = "Laboratory #2 for EEL4742 Embedded Systems";
  stringout(word);

  // go blink the light to indicate code is running
  P2DIR |= 0x02;  // Set P1.0 to output direction
  for (;;) {
    P2OUT ^= 0x02;  // Toggle P1.0 using exclusive-OR
    i = 10000; 		// SW Delay
    do{
      i--;
    }
    while (i != 0);
  }
}

void stringout(char Str2[]) {
  int k = 0 ;
  for (k = 0; Str2[k] != 0x00; k++)  OUTA_UART(Str2[k]); //print a char of the array index
  OUTA_UART(0x0D); // tells msp to move to the next line
  OUTA_UART(0X0A); // tells msp to end the program
}

void OUTA_UART(unsigned char A) {
  do {}
  while ((IFG2 & 0x02) == 0);
  UCA0TXBUF = A;
}

unsigned char INCHAR_UART(void) {
  do {}
  while ((IFG2 & 0x01) == 0);
  return (UCA0RXBUF);
}

void Init_UART(void) {
  P2SEL = 0x30;       // transmit and receive to port 2 bits 4 and 5
  UCA0CTL0 = 0;       // 8 data, no parity 1 stop, uart, async
  UCA0CTL1 = 0x41;
  UCA0BR1 = 0;        // upper byte of divider clock word
  UCA0BR0 = 3;        // clock divide from a clock to bit clock 32768/9600
  UCA0MCTL = 0x06;
  UCA0STAT = 0;       // do not loop the transmitter back to the
  UCA0CTL1 = 0x40;
  IE2 = 0;            // turn transmit interrupts off
}
