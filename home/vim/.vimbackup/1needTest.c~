#include "msp430fg4618.h"
#include "stdio.h"
#define SPACE 0x20

//---------------------------------------------------------------
// Console I/O through the on board UART for MSP 430X4XXX
//---------------------------------------------------------------
void  Init_UART(void);
void OUTA_UART(unsigned char A);
unsigned char INCHAR_UART(void);

unsigned char readValidInput(void);

int toValue(unsigned char c);



void toBinary(unsigned int n){
	if ( n <= 0 ){
		return ;
	}
	else{
		toBinary(n/2);
		OUTA_UART(n%2+0x30);
	}
}


void toBin(int k){
	int nbits = 4 ;
	while ( nbits > 0 ){
		OUTA_UART(k%2+0x30);
		k=k/2;
		nbits-- ;
	}
}


int main(void){

	volatile unsigned char a;
	volatile unsigned char b; 	// volatile to prevent optimization
	volatile unsigned char c;
	volatile unsigned char h;
	WDTCTL = WDTPW + WDTHOLD;   // Stop watchdog timer
	Init_UART();				// Intialize UART for hyperterminal

	for(;;){

		a = getValidInput();
		b = getValidInput();
		//OUTA_UART(a);
		//OUTA_UART(b); 	// get char 2 and print
		OUTA_UART(SPACE);	// space

		// Convert from ascii to values, sum
		//toBinary(toValue(a));
		toBinary(toValue(a));
		toBin(toValue(a));


		// Print 8 bit binary eq
		//toBin(sum);
	}
}


int toValue( unsigned char c ){
	int tmp = 0x00 ;
	// if A is "0-9"
	if (c > 0x2F && c < 0x3A){
		tmp=(c-0x30); 			// Subtract 0x30 from it to make into binary eq. value
	}
	// elif A is "A-F"
	else if ( c > 0x40 && c < 0x48){
		tmp = (c-0x37);
	}
	// else A is "a-f"
	else{
		tmp = (c-0x57);
	}
	return tmp ;
}


unsigned char readValidInput(void){
	unsigned char a = 0x00 ;
	// while a isn't a valid hex digit ( character 0-9 or character A-F or a-f )
	while (1){
		// get a char
		a = INCHAR_UART();
		/* Check if the chracter in a, is 0-9 or A-F or a-f */
		// If 0-9
		if ( a > 0x2F && a < 0x40 ) {
			OUTA_UART(a);
			return a ;
		}
		// elif A-F
		else if ( a > 0x40 && a < 0x47 ){
			OUTA_UART(a);
			return a-0x57 ;
		}
		// elif a-f
		else if ( a > 0x09 && a < 0x10 ){
			OUTA_UART(a);
			return a ;
		}
		// Reset a and reiterate
		else {
			a = 0x00 ;
		}
	}

}






























void OUTA_UART(unsigned char A) {
	//---------------------------------------------------------------
	//***************************************************************
	//---------------------------------------------------------------
	// IFG2 register (1) = 1 transmit buffer is empty,
	// UCA0TXBUF 8 bit transmit buffer
	// wait for the transmit buffer to be empty before sending the
	// data out

	do{}while ((IFG2&0x02)==0);

	// send the data to the transmit buffer

	UCA0TXBUF = A;
}

unsigned char INCHAR_UART(void){
	//---------------------------------------------------------------
	//***************************************************************
	//---------------------------------------------------------------
	// IFG2 register (0) = 1 receive buffer is full,
	// UCA0RXBUF 8 bit receive buffer
	// wait for the receive buffer is full before getting the data
	do{
	}while ((IFG2&0x01)==0);
	// go get the char from the receive buffer
	return (UCA0RXBUF);
}

void  Init_UART(void){
	//---------------------------------------------------------------
	// Initialization code to set up the uart on the experimenter
	// board to 8 data,
	// 1 stop, no parity, and 9600 baud, polling operation
	//---------------------------------------------------------------
	P2SEL=0x30;  // transmit and receive to port 2 b its 4 and 5
    // Bits p2.4 transmit and p2.5 receive
	UCA0CTL0=0;  // 8 data, no parity 1 stop, uart, async
	// (7)=1 (parity), (6)=1 Even, (5)= 0 lsb first,
	// (4)= 0 8 data / 1 7 data,
	// (3) 0 1 stop 1 / 2 stop, (2-1)  -- UART mode,
	// (0) 0 = async
	UCA0CTL1= 0x41;
	// select ALK 32768 and put in
	// software reset the UART
	// (7-6) 00 UCLK, 01 ACLK (32768 hz), 10 SMCLK,
	// 11 SMCLK
	// (0) = 1 reset
	UCA0BR1=0;  // upper byte of divider clock word
	UCA0BR0=3;  // clock divide from a clock to bit clock 32768/9600 = 3.413
	   // UCA0BR1:UCA0BR0 two 8 bit reg to from 16 bit
				 // clock divider
	   // for the baud rate
	UCA0MCTL=0x06;
				 // low frequency mode module 3 modulation pater
				 // used for the bit clock
	UCA0STAT=0;  // do not loop the transmitter back to the
				 // receiver for echoing
	// (7) = 1 echo back trans to rec
	// (6) = 1 framing, (5) = 1 overrun, (4) =1 Parity,
	// (3) = 1 break
	// (0) = 2 transmitting or receiving data
	UCA0CTL1=0x40;
	// take UART out of reset
	IE2=0;   // turn transmit interrupts off
	//---------------------------------------------------------------
	//***************************************************************
	//---------------------------------------------------------------
	// IFG2 register (0) = 1 receiver buffer is full,
	// UCA0RXIFG
	// IFG2 register (1) = 1 transmit buffer is empty,
	// UCA0RXIFG
	// UCA0RXBUF 8 bit receiver buffer
	// UCA0TXBUF 8 bit transmit buffer
}
