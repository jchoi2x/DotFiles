1.	Translate into MIPS64 assembly language. The variables in the code below are 64-bit integers.
	Address of 'a', 'b', 'c', and 'd' are 64, 72, 80, 88
		if ( a == b && a <= c){
			f = 4 ; 
		}

Ans. 

		LD R1,64(R0) 		# R1 = A ,( R1 <- Mem[64+0] ) 
		LD R2,72(R0)		# R2 = B ,( R2 <- Mem[72+0] )
		bne R1, R2, Skip	# if a != b, then branch immediately to Skip	
		LD R2,80(R0)		# R2 = C ,( R1 <- Mem[64+0] ) 
		bgt R1, R2, Skip	# if a > c, then branch to skip

		LI R2, #4			# R2 <- 4
		SD R2,88(R0)		# Mem[88] <- R2

	Skip:
		....

2.	Translate into MIPS64 assembly language. The variables in the code below are 64-bit double-precision 
    (floating point) numbers. 
    Address of 'a', 'b', 'c', and 'd' are 64, 72, 80, 88

		if ( a == b && a <= c){
			f = 4.14 ; 
		}

Ans.
		# Load a into F1
		L.D F1, 64(R0)

		# Load b into F2
		L.D F2, 72(R0) 

		# Compare not equal F1 and F2
		c.ne.d F1, F2
		# Branch if (coprocessor1) true
		bc1t Skip

		# Load c into R2
		L.D F2, 80(R0)

		# Compare greater than F1 and F2	
		c.gt.d F1, F2
		bc1t Skip

		# Load 4.14 into F2
		li.d F2, #4.56
		# Store to 88(R0)
		S.D F2, 88(R0)

	Skip:

3.  Translate into MIPS64 assembly language. The variables in the code below are 64-bit integers.
	Address of 'a', 'b', 'c', and 'd' are 64, 72, 80, 88
		if ( a < b || a != c ){
			f = 4 ; 
		}

Ans.
		LD R1,64(R0)  # R1 <- A
		LD R2,72(R0)  # R2 <- B

		# if a < b branch to calc
		blt R1, R2, Calc

		LD R2, 80(R0)

		# if a != c branch to calc
		bne R1, R2, Calc

		# otherwise, jump to exit
		jmp Skip

	Calc:
		LI R2, #4
		SD R2, 88(R0)
	
	Skip: 
		...

4.	Translate into MIPS64 assembly language. The variables in the code below are 64-bit double-precision 
    (floating point) numbers. 
    Address of 'a', 'b', 'c', and 'd' are 64, 72, 80, 88

		if ( a < b || a != c ){
			f = 4.56 ; 
		}



		# F1 <- a
		L.D F1, 64(R0)
		# F2 <- b 
		L.D F2, 72(R0) 


		# if A < B, branch and go str8 to Assicn 
		c.lt.d F1, F2
		bc1t Assign

		# F2 <- c
		L.D F2, 80(R0) 

		# if a!= c, branch to Assign
		c.ne.d F1,F2
		bc1t Assign

		J Done

	Assign
		li.d F2, #4.56
		s.d F2,88(R0)

	Done

5.	An array of double-precision (64-bit) floating-point numbers is located in the memory starting at Address
	1000. It contains 40 elements. Write a code that find the average of all the elements and puts the result 
	in register F31

		# R1 <- 1000
		li R1,#1000
		# Upper bound R2 <- 40
		li R2,#40 
		# lower bound
		dadd R3,R0,R0




	Loop

		# F2 <- Mem[1000+R2]
		l.d F2,0(R1)

		# F3 = F3 + F2	
		add.d F3,F3,F2


		# next index R1 = Sll(R2,3)
		dsll R1,R2,#3
		# Increment 
		daddi R2,R2,1
		# if R3 != R2 (40) , loop
		bne R2,R1,Loop

		# else
		# F4 <- R2
		MTC1 F4, R2
		# F4 <- ConvertDbl(F4)
		cvt.d.s F4,F4

		# Calculate The AVerage F31 <- F3(sum) / F4
		div.d F31,F3,F4



